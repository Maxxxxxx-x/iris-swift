// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: api_usage.sql

package sqlc

import (
	"context"
)

const getApiKeyUsageByKeyIdAndUserId = `-- name: GetApiKeyUsageByKeyIdAndUserId :many
SELECT api_usage.id, api_usage.api_key_id, api_usage.timestamp, api_usage.status_code, api_usage.response_time_ms, api_usage.request_ip, api_usage.from_addr, api_usage.to_addr, api_usage.subject, api_usage.status, api_usage.webhook FROM api_usage JOIN api_key ON api_usage.api_key_id = api_key.id
WHERE api_usage.api_key_id = ? AND api_key.created_by = ? ORDER BY api_usage.timestamp DESC
`

type GetApiKeyUsageByKeyIdAndUserIdParams struct {
	ApiKeyID  string `json:"api_key_id"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) GetApiKeyUsageByKeyIdAndUserId(ctx context.Context, arg GetApiKeyUsageByKeyIdAndUserIdParams) ([]ApiUsage, error) {
	rows, err := q.query(ctx, q.getApiKeyUsageByKeyIdAndUserIdStmt, getApiKeyUsageByKeyIdAndUserId, arg.ApiKeyID, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiUsage{}
	for rows.Next() {
		var i ApiUsage
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.Timestamp,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.RequestIp,
			&i.FromAddr,
			&i.ToAddr,
			&i.Subject,
			&i.Status,
			&i.Webhook,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
