// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package sqlc

import (
	"context"
	"database/sql"
)

const approveUserByEmail = `-- name: ApproveUserByEmail :exec
UPDATE users SET approved_by = ?, account_type = 'user' WHERE email = ?
`

type ApproveUserByEmailParams struct {
	ApprovedBy sql.NullString `json:"approved_by"`
	Email      string         `json:"email"`
}

func (q *Queries) ApproveUserByEmail(ctx context.Context, arg ApproveUserByEmailParams) error {
	_, err := q.exec(ctx, q.approveUserByEmailStmt, approveUserByEmail, arg.ApprovedBy, arg.Email)
	return err
}

const approveUserById = `-- name: ApproveUserById :exec
UPDATE users SET approved_by = ?, account_type = 'user' WHERE id = ?
`

type ApproveUserByIdParams struct {
	ApprovedBy sql.NullString `json:"approved_by"`
	ID         string         `json:"id"`
}

func (q *Queries) ApproveUserById(ctx context.Context, arg ApproveUserByIdParams) error {
	_, err := q.exec(ctx, q.approveUserByIdStmt, approveUserById, arg.ApprovedBy, arg.ID)
	return err
}

const approveUserByUsername = `-- name: ApproveUserByUsername :exec
UPDATE users SET approved_by = ?, account_type = 'user' WHERE username = ?
`

type ApproveUserByUsernameParams struct {
	ApprovedBy sql.NullString `json:"approved_by"`
	Username   string         `json:"username"`
}

func (q *Queries) ApproveUserByUsername(ctx context.Context, arg ApproveUserByUsernameParams) error {
	_, err := q.exec(ctx, q.approveUserByUsernameStmt, approveUserByUsername, arg.ApprovedBy, arg.Username)
	return err
}

const blacklistUserByEmail = `-- name: BlacklistUserByEmail :exec
UPDATE users SET is_blacklisted = 1, blacklisted_by = ?, blacklist_reason = ?  WHERE email = ?
`

type BlacklistUserByEmailParams struct {
	BlacklistedBy   sql.NullString `json:"blacklisted_by"`
	BlacklistReason sql.NullString `json:"blacklist_reason"`
	Email           string         `json:"email"`
}

func (q *Queries) BlacklistUserByEmail(ctx context.Context, arg BlacklistUserByEmailParams) error {
	_, err := q.exec(ctx, q.blacklistUserByEmailStmt, blacklistUserByEmail, arg.BlacklistedBy, arg.BlacklistReason, arg.Email)
	return err
}

const blacklistUserById = `-- name: BlacklistUserById :exec
UPDATE users SET is_blacklisted = 1, blacklisted_by = ?, blacklist_reason = ?  WHERE id = ?
`

type BlacklistUserByIdParams struct {
	BlacklistedBy   sql.NullString `json:"blacklisted_by"`
	BlacklistReason sql.NullString `json:"blacklist_reason"`
	ID              string         `json:"id"`
}

func (q *Queries) BlacklistUserById(ctx context.Context, arg BlacklistUserByIdParams) error {
	_, err := q.exec(ctx, q.blacklistUserByIdStmt, blacklistUserById, arg.BlacklistedBy, arg.BlacklistReason, arg.ID)
	return err
}

const blacklistUserByUsername = `-- name: BlacklistUserByUsername :exec
UPDATE users SET is_blacklisted = 1, blacklisted_by = ?, blacklist_reason = ?  WHERE username = ?
`

type BlacklistUserByUsernameParams struct {
	BlacklistedBy   sql.NullString `json:"blacklisted_by"`
	BlacklistReason sql.NullString `json:"blacklist_reason"`
	Username        string         `json:"username"`
}

func (q *Queries) BlacklistUserByUsername(ctx context.Context, arg BlacklistUserByUsernameParams) error {
	_, err := q.exec(ctx, q.blacklistUserByUsernameStmt, blacklistUserByUsername, arg.BlacklistedBy, arg.BlacklistReason, arg.Username)
	return err
}

const createUserRecord = `-- name: CreateUserRecord :one
INSERT INTO users (
    id, username, email, password
) VALUES (
    ?, ?, ?, ?
) RETURNING id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at
`

type CreateUserRecordParams struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUserRecord(ctx context.Context, arg CreateUserRecordParams) (User, error) {
	row := q.queryRow(ctx, q.createUserRecordStmt, createUserRecord,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ChangePassword,
		&i.ApprovedBy,
		&i.AccountType,
		&i.IsBlacklisted,
		&i.BlacklistedBy,
		&i.BlacklistReason,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserByEmail = `-- name: DeleteUserByEmail :exec
DELETE FROM users WHERE email = ?
`

func (q *Queries) DeleteUserByEmail(ctx context.Context, email string) error {
	_, err := q.exec(ctx, q.deleteUserByEmailStmt, deleteUserByEmail, email)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUserById(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteUserByIdStmt, deleteUserById, id)
	return err
}

const deleteUserByUserName = `-- name: DeleteUserByUserName :exec
DELETE FROM users WHERE username = ?
`

func (q *Queries) DeleteUserByUserName(ctx context.Context, username string) error {
	_, err := q.exec(ctx, q.deleteUserByUserNameStmt, deleteUserByUserName, username)
	return err
}

const forcePasswordChangeByEmail = `-- name: ForcePasswordChangeByEmail :exec
UPDATE users SET change_password = 1 WHERE email = ?
`

func (q *Queries) ForcePasswordChangeByEmail(ctx context.Context, email string) error {
	_, err := q.exec(ctx, q.forcePasswordChangeByEmailStmt, forcePasswordChangeByEmail, email)
	return err
}

const forcePasswordChangeById = `-- name: ForcePasswordChangeById :exec
UPDATE users SET change_password = 1 WHERE id = ?
`

func (q *Queries) ForcePasswordChangeById(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.forcePasswordChangeByIdStmt, forcePasswordChangeById, id)
	return err
}

const forcePasswordChangeByUsername = `-- name: ForcePasswordChangeByUsername :exec
UPDATE users SET change_password = 1 WHERE username = ?
`

func (q *Queries) ForcePasswordChangeByUsername(ctx context.Context, username string) error {
	_, err := q.exec(ctx, q.forcePasswordChangeByUsernameStmt, forcePasswordChangeByUsername, username)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.getAllUsersStmt, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ChangePassword,
			&i.ApprovedBy,
			&i.AccountType,
			&i.IsBlacklisted,
			&i.BlacklistedBy,
			&i.BlacklistReason,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ChangePassword,
		&i.ApprovedBy,
		&i.AccountType,
		&i.IsBlacklisted,
		&i.BlacklistedBy,
		&i.BlacklistReason,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id string) (User, error) {
	row := q.queryRow(ctx, q.getUserByIdStmt, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ChangePassword,
		&i.ApprovedBy,
		&i.AccountType,
		&i.IsBlacklisted,
		&i.BlacklistedBy,
		&i.BlacklistReason,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIdentifier = `-- name: GetUserByIdentifier :one
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE username = ? OR email = ? LIMIT 1
`

type GetUserByIdentifierParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserByIdentifier(ctx context.Context, arg GetUserByIdentifierParams) (User, error) {
	row := q.queryRow(ctx, q.getUserByIdentifierStmt, getUserByIdentifier, arg.Username, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ChangePassword,
		&i.ApprovedBy,
		&i.AccountType,
		&i.IsBlacklisted,
		&i.BlacklistedBy,
		&i.BlacklistReason,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ChangePassword,
		&i.ApprovedBy,
		&i.AccountType,
		&i.IsBlacklisted,
		&i.BlacklistedBy,
		&i.BlacklistReason,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsersApprover = `-- name: GetUsersApprover :many
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE approved_by = ?
`

func (q *Queries) GetUsersApprover(ctx context.Context, approvedBy sql.NullString) ([]User, error) {
	rows, err := q.query(ctx, q.getUsersApproverStmt, getUsersApprover, approvedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ChangePassword,
			&i.ApprovedBy,
			&i.AccountType,
			&i.IsBlacklisted,
			&i.BlacklistedBy,
			&i.BlacklistReason,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersOfAccountType = `-- name: GetUsersOfAccountType :many
SELECT id, username, email, password, change_password, approved_by, account_type, is_blacklisted, blacklisted_by, blacklist_reason, updated_at FROM users WHERE account_type = ?
`

func (q *Queries) GetUsersOfAccountType(ctx context.Context, accountType string) ([]User, error) {
	rows, err := q.query(ctx, q.getUsersOfAccountTypeStmt, getUsersOfAccountType, accountType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ChangePassword,
			&i.ApprovedBy,
			&i.AccountType,
			&i.IsBlacklisted,
			&i.BlacklistedBy,
			&i.BlacklistReason,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountTypeByEmail = `-- name: UpdateAccountTypeByEmail :exec
UPDATE users SET account_type = ? WHERE email = ?
`

type UpdateAccountTypeByEmailParams struct {
	AccountType string `json:"account_type"`
	Email       string `json:"email"`
}

func (q *Queries) UpdateAccountTypeByEmail(ctx context.Context, arg UpdateAccountTypeByEmailParams) error {
	_, err := q.exec(ctx, q.updateAccountTypeByEmailStmt, updateAccountTypeByEmail, arg.AccountType, arg.Email)
	return err
}

const updateAccountTypeById = `-- name: UpdateAccountTypeById :exec
UPDATE users SET account_type = ? WHERE id = ?
`

type UpdateAccountTypeByIdParams struct {
	AccountType string `json:"account_type"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateAccountTypeById(ctx context.Context, arg UpdateAccountTypeByIdParams) error {
	_, err := q.exec(ctx, q.updateAccountTypeByIdStmt, updateAccountTypeById, arg.AccountType, arg.ID)
	return err
}

const updateAccountTypeByUsername = `-- name: UpdateAccountTypeByUsername :exec
UPDATE users SET account_type = ? WHERE username = ?
`

type UpdateAccountTypeByUsernameParams struct {
	AccountType string `json:"account_type"`
	Username    string `json:"username"`
}

func (q *Queries) UpdateAccountTypeByUsername(ctx context.Context, arg UpdateAccountTypeByUsernameParams) error {
	_, err := q.exec(ctx, q.updateAccountTypeByUsernameStmt, updateAccountTypeByUsername, arg.AccountType, arg.Username)
	return err
}

const updatePasswordByEmail = `-- name: UpdatePasswordByEmail :exec
UPDATE users SET password = ? WHERE email = ?
`

type UpdatePasswordByEmailParams struct {
	Password string `json:"password"`
	Email    string `json:"email"`
}

func (q *Queries) UpdatePasswordByEmail(ctx context.Context, arg UpdatePasswordByEmailParams) error {
	_, err := q.exec(ctx, q.updatePasswordByEmailStmt, updatePasswordByEmail, arg.Password, arg.Email)
	return err
}

const updatePasswordByUsername = `-- name: UpdatePasswordByUsername :exec
UPDATE users SET password = ? WHERE username = ?
`

type UpdatePasswordByUsernameParams struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

func (q *Queries) UpdatePasswordByUsername(ctx context.Context, arg UpdatePasswordByUsernameParams) error {
	_, err := q.exec(ctx, q.updatePasswordByUsernameStmt, updatePasswordByUsername, arg.Password, arg.Username)
	return err
}

const updatePasswordByid = `-- name: UpdatePasswordByid :exec
UPDATE users SET password = ? WHERE id = ?
`

type UpdatePasswordByidParams struct {
	Password string `json:"password"`
	ID       string `json:"id"`
}

func (q *Queries) UpdatePasswordByid(ctx context.Context, arg UpdatePasswordByidParams) error {
	_, err := q.exec(ctx, q.updatePasswordByidStmt, updatePasswordByid, arg.Password, arg.ID)
	return err
}
