// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: api_key.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteApiKeyByCreatorId = `-- name: DeleteApiKeyByCreatorId :exec
DELETE FROM api_key WHERE created_by = ?
`

func (q *Queries) DeleteApiKeyByCreatorId(ctx context.Context, createdBy string) error {
	_, err := q.exec(ctx, q.deleteApiKeyByCreatorIdStmt, deleteApiKeyByCreatorId, createdBy)
	return err
}

const deleteApiKeyById = `-- name: DeleteApiKeyById :exec
DELETE FROM api_key WHERE id = ?
`

func (q *Queries) DeleteApiKeyById(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteApiKeyByIdStmt, deleteApiKeyById, id)
	return err
}

const getApiKeyByCreatorId = `-- name: GetApiKeyByCreatorId :many
SELECT id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id FROM api_key WHERE created_by = ? ORDER BY created_at DESC
`

func (q *Queries) GetApiKeyByCreatorId(ctx context.Context, createdBy string) ([]ApiKey, error) {
	rows, err := q.query(ctx, q.getApiKeyByCreatorIdStmt, getApiKeyByCreatorId, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyHash,
			&i.Name,
			&i.AllowedDomains,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.UsageCount,
			&i.LastUsedAt,
			&i.LastUsedIp,
			&i.LastUsedID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeyByIdAndCreatorId = `-- name: GetApiKeyByIdAndCreatorId :one
SELECT id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id FROM api_key WHERE id = ? AND created_by = ? LIMIT 1
`

type GetApiKeyByIdAndCreatorIdParams struct {
	ID        string `json:"id"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) GetApiKeyByIdAndCreatorId(ctx context.Context, arg GetApiKeyByIdAndCreatorIdParams) (ApiKey, error) {
	row := q.queryRow(ctx, q.getApiKeyByIdAndCreatorIdStmt, getApiKeyByIdAndCreatorId, arg.ID, arg.CreatedBy)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKeyHash,
		&i.Name,
		&i.AllowedDomains,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsageCount,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.LastUsedID,
	)
	return i, err
}

const getApiKeyByKeyHash = `-- name: GetApiKeyByKeyHash :one
SELECT id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id FROM api_key WHERE api_key_hash = ? LIMIT 1
`

func (q *Queries) GetApiKeyByKeyHash(ctx context.Context, apiKeyHash string) (ApiKey, error) {
	row := q.queryRow(ctx, q.getApiKeyByKeyHashStmt, getApiKeyByKeyHash, apiKeyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKeyHash,
		&i.Name,
		&i.AllowedDomains,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsageCount,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.LastUsedID,
	)
	return i, err
}

const getApiKeyByNameAndCreatorId = `-- name: GetApiKeyByNameAndCreatorId :many
SELECT id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id FROM api_key WHERE name = ? AND created_by = ?
ORDER BY created_at DESC
`

type GetApiKeyByNameAndCreatorIdParams struct {
	Name      string `json:"name"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) GetApiKeyByNameAndCreatorId(ctx context.Context, arg GetApiKeyByNameAndCreatorIdParams) ([]ApiKey, error) {
	rows, err := q.query(ctx, q.getApiKeyByNameAndCreatorIdStmt, getApiKeyByNameAndCreatorId, arg.Name, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyHash,
			&i.Name,
			&i.AllowedDomains,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.UsageCount,
			&i.LastUsedAt,
			&i.LastUsedIp,
			&i.LastUsedID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeys = `-- name: GetApiKeys :many
SELECT id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id FROM api_key ORDER BY created_at DESC
`

func (q *Queries) GetApiKeys(ctx context.Context) ([]ApiKey, error) {
	rows, err := q.query(ctx, q.getApiKeysStmt, getApiKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyHash,
			&i.Name,
			&i.AllowedDomains,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.UsageCount,
			&i.LastUsedAt,
			&i.LastUsedIp,
			&i.LastUsedID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshApiKey = `-- name: RefreshApiKey :exec
UPDATE api_key
SET api_key_hash = ? WHERE id = ?
`

type RefreshApiKeyParams struct {
	ApiKeyHash string `json:"api_key_hash"`
	ID         string `json:"id"`
}

func (q *Queries) RefreshApiKey(ctx context.Context, arg RefreshApiKeyParams) error {
	_, err := q.exec(ctx, q.refreshApiKeyStmt, refreshApiKey, arg.ApiKeyHash, arg.ID)
	return err
}

const saveApiKey = `-- name: SaveApiKey :one
INSERT INTO api_key
(id, api_key_hash, name, allowed_domains, created_by, expires_at)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, api_key_hash, name, allowed_domains, created_by, created_at, expires_at, usage_count, last_used_at, last_used_ip, last_used_id
`

type SaveApiKeyParams struct {
	ID             string       `json:"id"`
	ApiKeyHash     string       `json:"api_key_hash"`
	Name           string       `json:"name"`
	AllowedDomains string       `json:"allowed_domains"`
	CreatedBy      string       `json:"created_by"`
	ExpiresAt      sql.NullTime `json:"expires_at"`
}

func (q *Queries) SaveApiKey(ctx context.Context, arg SaveApiKeyParams) (ApiKey, error) {
	row := q.queryRow(ctx, q.saveApiKeyStmt, saveApiKey,
		arg.ID,
		arg.ApiKeyHash,
		arg.Name,
		arg.AllowedDomains,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKeyHash,
		&i.Name,
		&i.AllowedDomains,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsageCount,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.LastUsedID,
	)
	return i, err
}
